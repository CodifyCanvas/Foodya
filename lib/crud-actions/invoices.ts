'use server';

import { and, eq } from 'drizzle-orm';
import { db } from '../db';
import { schema } from '../drizzle-schema';
import { deleteData, insertData, updateData } from './general-actions';
import { InvoiceResponse, OrderItem } from '../definations';



// === Drizzle table schemas ===
const invoices = schema.InvoicesTable;
const orders = schema.ordersTable;
const orderItems = schema.orderItemsTable;
const users = schema.users;
const roles = schema.roles;
const transactionsTable = schema.transactionsTable;



/**
 * === Fetch Full Invoice by ID ===
 *
 * - Retrieves the invoice, related order, and all order items.
 * - Also fetches the user who generated the invoice.
 * - Normalizes data types (e.g., IDs converted to strings).
 *
 * @param {number} invoiceId - The ID of the invoice to retrieve.
 * @returns {Promise<InvoiceResponse | null>} Complete invoice data or null if not found.
 */
export const fetchInvoice = async (invoiceId: number): Promise<InvoiceResponse | null> => {

  // === Step 0: Validate Input ===
  if (!invoiceId) return null;

  // === Step 1: Fetch invoice ===
  const [invoice] = await db
    .select()
    .from(invoices)
    .where(eq(invoices.id, invoiceId));

  if (!invoice) return null;

  // === Step 2: Fetch related order ===
  const [order] = await db
    .select()
    .from(orders)
    .where(eq(orders.id, invoice.orderId));

  if (!order) return null;

  // === Step 3: Fetch order items ===
  const raworderItemsData = await db
    .select()
    .from(orderItems)
    .where(eq(orderItems.orderId, order.id));

  // === Step 4: Fetch user who generated the invoice ===
  let user = null;
  if (invoice.generatedByUserId !== null) {
    const [fetchedUser] = await db
      .select({
        id: users.id,
        name: users.name,
        email: users.email,
      })
      .from(users)
      .where(eq(users.id, invoice.generatedByUserId));

    user = fetchedUser ?? null;
  }

  // === Step 5: Normalize order fields ===
  const formattedOrder = {
    ...order,
    tableId: order.tableId !== null ? String(order.tableId) : "",
    waiterId: order.waiterId !== null ? String(order.waiterId) : "",
    createdAt: order.createdAt.toISOString(),
  };

  // === Step 6: Normalize order items ===
  const orderItemsData = raworderItemsData.map((item) => ({
    ...item,
    menuItemId: String(item.menuItemId),
    menuItemOptionId: (item.menuItemOptionId !== null) ? String(item.menuItemOptionId) : null,
  }));

  // === Step 7: Normalize Invoice Data ===
  const invoiceData = {
    ...invoice,
    paymentMethod: (invoice.paymentMethod ?? 'unpaid') as 'cash' | 'card' | 'online' | 'unpaid',
    createdAt: invoice.createdAt.toISOString(),
  };

  // === Step 8: Normalize Generated by User ===
  const generatedBy = user
    ? {
      id: user.id,
      name: user.name ?? '',
      email: user.email,
    }
    : null;

  // === Step 8: Return complete object ===
  return {
    invoice: invoiceData,
    order: formattedOrder,
    items: orderItemsData,
    generatedBy: generatedBy,
  };
};



/**
 * === Get All Users with a Specific Role ===
 *
 * - Performs a LEFT JOIN on `roles` and `users` tables.
 * - Filters users based on a provided role name.
 * - Used for retrieving users like waiters, managers, etc.
 *
 * @param {string} roleName - The role name to filter users by (e.g. "waiter").
 * @returns List of users matching the role, or null if roleName is missing.
 */
export const getAllWaiters = async (roleName: string) => {

  // === Validate Input ===
  if (!roleName) return null;

  // === Query Users by Role ===
  const result = await db
    .select({
      id: users.id,
      name: users.name,
      email: users.email,
      isActive: users.is_active,
      role: roles.role,
    })
    .from(users)
    .leftJoin(roles, eq(roles.id, users.role_id))
    .where(eq(roles.role, roleName));

  // === Return Users Matching Role ===
  return result;
};



/**
 * Handles full invoice creation or update within a transaction.
 *
 * @param {any} parsed - Parsed invoice/order data object.
 * @param {number} userId - ID of the user creating/updating the invoice.
 * @param {'insert' | 'update'} mode - Mode of operation, either 'insert' or 'update'.
 *
 * @returns {Promise<number | { invoiceId: number }>} The inserted invoice ID or updated invoice ID object.
 *
 * @throws {Error} If required data is missing or mode is invalid.
 */
export async function upsertInvoiceOrderItemsTx(parsed: any, userId: number, mode: 'insert' | 'update'): Promise<{ invoiceId: number }> {

  // === Validation Inputs ===
  if (!parsed) throw new Error("Data Fields is not provided");
  if (!userId) throw new Error("Please Provide The UserId");

  if (mode === 'insert') {
    return await db.transaction(async (tx) => {

      // === Insert new order ===
      const orderResult = await insertData("ordersTable", {
        tableId: parsed.tableId ? Number(parsed.tableId) : null,
        waiterId: Number(userId),
        orderType: parsed.orderType.trim(),
        status: 'completed',
        createdAt: parsed.orderCreatedAt,
      }, tx);

      const newOrderId = orderResult.insertId;
      if (!newOrderId) throw new Error("Order creation failed");

      // === Insert associated order items ===
      if (parsed.orderItems?.length) {
        const insertPromises = parsed.orderItems.map((item: OrderItem) => {
          const parsedOptionId = Number(item.menuItemOptionId);

          insertData("orderItemsTable", {
            orderId: newOrderId,
            menuItemImage: item.menuItemImage || null,
            menuItemId: Number(item.menuItemId),
            menuItemName: item.menuItemName,
            menuItemOptionId: parsedOptionId > 0 ? parsedOptionId : null,
            menuItemOptionName: item.menuItemOptionName || null,
            quantity: item.quantity,
            price: item.price,
          }, tx)
        });
        await Promise.all(insertPromises);
      }

      // === Insert invoice ===
      const invoiceId = await insertData("InvoicesTable", {
        orderId: newOrderId,
        generatedByUserId: Number(userId),
        customerName: typeof parsed.customerName === "string" && parsed.customerName.trim() ? parsed.customerName.trim() : undefined,
        subTotalAmount: parsed.subTotalAmount,
        discount: parsed.discount ?? "0.00",
        totalAmount: parsed.totalAmount,
        advancePaid: parsed.advancePaid ?? "0.00",
        grandTotal: parseFloat(parsed.grandTotal) < 0 ? "0.00" : parseFloat(parsed.grandTotal).toFixed(2),
        isPaid: parsed.isPaid,
        paymentMethod: parsed.paymentMethod,
      }, tx);

      // === Insert transaction if paid ===
      if (parsed.isPaid) {
        await insertData("transactionsTable", {
          categoryId: 2,
          title: 'Customer Invoice',
          amount: parseFloat(parsed.grandTotal) < 0 ? "0.00" : parseFloat(parsed.grandTotal).toFixed(2),
          type: 'credit',
          sourceType: 'invoice',
          sourceId: invoiceId.insertId
        }, tx)
      }

      // === Return Invoice ID ===
      return { invoiceId: invoiceId.insertId };
    });
  } else if (mode === 'update') {

    if (!parsed.orderId || !parsed.invoiceId) {
      throw new Error("Missing orderId or invoiceId for update mode");
    }

    return await db.transaction(async (tx) => {

      // === Update existing order ===
      await updateData("ordersTable", 'id', parsed.orderId, {
        tableId: parsed.tableId ? Number(parsed.tableId) : null,
        orderType: parsed.orderType.trim(),
        createdAt: parsed.orderCreatedAt,
      }, tx);

      // === Delete existing order items for this order ===
      await deleteData("orderItemsTable", "orderId", parsed.orderId, tx);

      // === Insert updated order items ===
      if (parsed.orderItems?.length > 0) {
        const insertPromises = parsed.orderItems.map((item: OrderItem) =>
          insertData("orderItemsTable", {
            orderId: parsed.orderId,
            menuItemImage: item.menuItemImage || null,
            menuItemId: Number(item.menuItemId),
            menuItemName: item.menuItemName,
            menuItemOptionId: item.menuItemOptionId != null ? Number(item.menuItemOptionId) : null,
            menuItemOptionName: item.menuItemOptionName ?? null,
            quantity: item.quantity,
            price: item.price,
          }, tx)
        );
        await Promise.all(insertPromises);
      }

      // === Update invoice data ===
      await updateData("InvoicesTable", "id", parsed.invoiceId, {
        customerName: typeof parsed.customerName === "string" && parsed.customerName.trim() ? parsed.customerName.trim() : undefined,
        subTotalAmount: parsed.subTotalAmount,
        discount: parsed.discount ?? "0.00",
        totalAmount: parsed.totalAmount,
        advancePaid: parsed.advancePaid ?? "0.00",
        grandTotal: parseFloat(parsed.grandTotal) < 0 ? "0.00" : parseFloat(parsed.grandTotal).toFixed(2),
        isPaid: parsed.isPaid,
        paymentMethod: parsed.paymentMethod,
      }, tx);

      // === Handle transactions based on payment status ===
      if (parsed.isPaid) {
        const amount = parseFloat(parsed.grandTotal) < 0 ? "0.00" : parseFloat(parsed.grandTotal).toFixed(2);

        // CASE 01: check if transaction exists
        const existingTransaction = await tx.select()
          .from(transactionsTable)
          .where(and(eq(transactionsTable.sourceType, 'invoice'), eq(transactionsTable.sourceId, parsed.invoiceId)))
          .then(rows => rows[0]);

        // CASE 02: check if transaction exists is true then update it
        if (existingTransaction) {
          await tx.update(transactionsTable).set({
            amount,
          }).where(and(eq(transactionsTable.sourceType, 'invoice'), eq(transactionsTable.sourceId, parsed.invoiceId)));

        } else {
          // CASE 03: check if transaction is not exists then insert
          await insertData("transactionsTable", {
            categoryId: 2,
            title: 'Customer Invoice',
            amount,
            type: 'credit',
            sourceType: 'invoice',
            sourceId: parsed.invoiceId
          }, tx);
        }
      } else {
        // CASE 04: if isPaid is false then delete the existing transaction
        await tx.delete(transactionsTable).where(and(eq(transactionsTable.sourceType, 'invoice'), eq(transactionsTable.sourceId, parsed.invoiceId)));
      }

      // === Return updated invoice ID ===
      return { invoiceId: parsed.invoiceId };
    });

  } else {
    throw new Error("Mode is Not Provided or valid");
  }
}



/**
 * Deletes an invoice and all related records (order, order items, transactions) within a database transaction.
 *
 * @param {number} id - The ID of the invoice to be deleted.
 * 
 * @returns {Promise<void>} Resolves when the transaction completes successfully.
 *
 * @throws {Error} If the invoice is not found or deletion fails.
 */
export const deleteInvoiceWithTransaction = async (id: number): Promise<void> => {
  if (!id) throw new Error('Oops! No invoice ID was provided for deletion.');

  await db.transaction(async (tx) => {

    // === Fetch invoice and its associated order ID ===
    const [invoice] = await tx.select({ id: invoices.id, orderId: invoices.orderId }).from(invoices).where(eq(invoices.id, id));

    if (!invoice) {
      throw new Error(`Invoice with ID ${id} not found.`);
    }

    // === Delete all related order items (by orderId) ===
    await deleteData("orderItemsTable", 'orderId', invoice.orderId, tx);

    // === Delete the related order (by orderId) ===
    await deleteData("ordersTable", 'id', invoice.orderId, tx);

    // === Delete the invoice itself ===
    await deleteData("InvoicesTable", 'id', id, tx);


    // === Delete related transactions that reference this invoice ===
    await tx.delete(transactionsTable).where(and(
      eq(transactionsTable.sourceType, 'invoice'),
      eq(transactionsTable.sourceId, id)
    ));
  });
};